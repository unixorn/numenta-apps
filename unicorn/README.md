# Numenta Unicorn

> Cross-platform Desktop Application to demonstrate basic HTM functionality to
> users using their own data files.


## WARNING! CURRENTLY UNDER HEAVY DEVELOPMENT


## License

Dual Commercial and AGPLv3 License. See [LICENSE.txt](LICENSE.txt)
and http://numenta.org/licenses/.


## Repository

The `frontend/` directory contains Cross-platform Desktop Application GUI code,
running Javascript/HTML/CSS/etc. on [Node.js](https://nodejs.org/),
[Electron](https://github.com/atom/electron), and
[Google Chromium](https://www.chromium.org/Home). It also contains non-GUI logic
to run and manage HTM Models on the Unicorn `backend/` model runner.

The `backend/` directory contains Unicorn ModelRunner and supporting code
(Python / C++), which drives the main functionality of the app, which it is our
goal to demo to the user.

```shell
DEPENDENCIES.md     # Module dependency overview file
LICENSE.txt         # Dual: Commercial and AGPLv3
README.md           # This file, a project overview
backend/            # Unicorn ModelRunner and support Python/C++ code here!
  README.md         # Overview for HTM/NuPIC part of project
  requirements.txt  # Python pip package dependencies
  setup.py          # Backend Python project initialization tooling
frontend/           # Frontend+GUI that exposes NuPIC HTM functionality to the User
  README.md         # Overview for Frontend+GUI part of project
  browser/          # Javascript, HTML, CSS act as GUI inside browser window
    app.js          # Fluxible GUI Browser Web App entry, compiles to bundle.js
    bundle.js       # Autogenerated WebPack output compiled Javascript bundle
    bundle.js.map   # JS Sourcemap for Autogenerated WebPack Javascript bundle
    index.html      # App main startup browser window contents
    actions/        # Fluxible Actions JS
    components/     # React view components JSX
    lib/            # Custom JS libs for inside the browser (engine clients)
    stores/         # Fluxible Stores JS
  config/           # JS Config files loaded by nconf
  database/         # File-based JSON database storage (levelup + jsondown)
    data/           # Local JSON file DB log (not in source control)
    schema/         # Database defintion schemas in JSON
  lib/              # Custom JS libs for outside the browser (engine servers)
  loader.js         # Electron App entry point loader for main.js ES5 => ES6
  main.js           # ES6 Electron App main entry, creates browser GUI window and model runner engine
  samples/          # Sample .CSV data files to pre-load for user in GUI
  test/             # Frontend tests run by Mocha: Unit, etc.
    unit/           # Frontend+GUI Unit tests
gulpfile.babel.js   # Babel.js ES6 Config file for the Gulp build tool
node_modules/       # Where `npm` installs packages to
package.json        # Node.js `npm` packages, dependencies, and App config
```


## Technology


### Backend

#### Stack

> See: `backend/requirements.txt`

* Languages:
  * [Python](http://python.org)
  * [C++](https://isocpp.org/)
* Machine Intelligence:
  * [NuPIC](htts://github.com/numenta/nupic)

#### Description

The Machine Intelligence behind this app is a technology known as Hierarchical
Temporal Memory (HTM). NuPIC is Numenta's open source HTM engine. NuPIC runs
on streams of data, predicting future values, and detecting pattern anomalies.

#### Guidelines

* Python coding guidelines @TODO
* C++ coding guidelines @TODO


### Frontend

#### Stack

> See: `package.json`

* Languages:
  * Javascript
    * [ECMAScript 5.1](https://es5.github.io/) (>= IE9)
    * [ECMAScript 6](https://babeljs.io/docs/learn-es2015/) (aka ES2015) via
      [Babel](https://babeljs.io/)
    * Some experimental [ECMAScript 7](https://babeljs.io/docs/usage/experimental/)
      features via [Babel](https://babeljs.io/)
    * Facebook [Flow](http://flowtype.org/) JS Typing
  * [HTML5](https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/HTML5)
  * [CSS3](https://developer.mozilla.org/en-US/docs/Web/CSS) with
    [SASS](http://sass-lang.com/) via
    [node-sass](https://github.com/sass/node-sass)
* Framework: [Electron](https://github.com/atom/electron)
  * Engines: [Chromium](https://www.chromium.org/Home),
    [IO.js](https://iojs.org/), [Node](https://github.com/joyent/node)
    * Package Manager: [npm](https://www.npmjs.com/)
    * Module Loading and Bundling: [WebPack](https://github.com/webpack/webpack)
    * Configuration: [nconf](https://github.com/indexzero/nconf)
  * User Interface:
    * Architecture: [Fluxible](http://fluxible.io/)
      ([Flux](https://facebook.github.io/flux/docs/overview.html#content)
      Uni-directional data flow)
    * View Components: [React](https://github.com/facebook/react),
      [JSX](https://facebook.github.io/jsx/)
    * Graphing and Charting: [DyGraphs](http://dygraphs.com/)
      * @TODO Alternatives: [react-chartjs](https://github.com/jhudson8/react-chartjs)
        Canvas, [react-d3](https://github.com/esbullington/react-d3) SVG
    * HD Images: [Retina.js](http://imulus.github.io/retinajs/)
* Testing:
  * Test Runner, Unit Tests: [Mocha](https://github.com/mochajs/mocha)
  * Web Tests: [Casper](https://github.com/n1k0/casperjs)
* Tooling:
  * Streaming task runner: [Gulp](https://github.com/gulpjs/gulp)
  * JS transpiling (ES6, JSX, etc): [Babel](https://github.com/babel/babel)
  * Linting: [eslint](http://eslint.org/)

#### Description

The Frontend contains code to manage Models on the Backend. It also contians
the Graphical User Interface that allows users to explore HTM Models on their
own data.

The GUI for this application is web code. Javascript, HTML, and CSS are loaded
into a browser. For Desktop, this browser is a bare-bones Chrome window opened
by the Electron framework. Electron also runs IO.js (Node.js edge) to connect
with the host Operating System, allowing for cross-platform native controls.

In the browser, we run a one-way Uni-directional data flow, an Architecture
known as "Flux".

Below is an example of tracing of our way through GUI initialization, GUI first
loop run, and GUI loop continuation:

1. Electron loads `frontend/main.js`
1. .. which (or Browser directly) loads `frontend/browser/index.html`
1. .. which loads `frontend/browser/js/app.js`
1. .. which inits Fluxible
1. .. and then Fluxible fires off an initial Action
1. .. which dispatches Events with state data to Stores
1. .. which then integrate state data into themselves
1. .. and then View Components tied to updated Stores render
1. .. and then The User interacts with the app firing off a new Action
1. .. GOTO #6, RINSE and REPEAT.

#### Guidelines

* [ES5 Styleguide](https://github.com/felixge/node-style-guide)
* ES6 styleguide @TODO
  * **Exception:** OK to occasionally have non-all-caps `const`, i.e. class
    constructors, immutable data structures, etc.
* Flow Typing styleguide @TODO
* HTML @TODO
* CSS @TODO


## Development


### Instructions

#### Setup

Example of setting up development environment on Mac OS/X:

```shell
brew install git node
git clone https://github.com/numenta/numenta-apps
cd numenta-apps/unicorn
pip install -r backend/requirements.txt
npm install
```

#### Desktop App

Start code via Electron as a Desktop App:

```shell
# desktop dev (same)
$ npm run desktop
$ NODE_ENV=development npm run desktop

# desktop prod
$ NODE_ENV=production npm run desktop
```

#### Web App

This is *nice-to-have*, and *not* required like the Desktop App. The more this
Web version stays synced with the Desktop version, the easier it will be to
later port this to a real Web App, or to Android/iOS mobile via
[React Native](https://facebook.github.io/react-native/).

Start app on local webserver, you can open it with Chrome Browser
at `http://localhost:9999`:

```shell
# web dev (same)
$ npm run web
$ NODE_ENV=development npm run web

# web prod
$ NODE_ENV=production npm run web
```

#### Testing

Write **Unit** and **Integration** tests using [mocha](https://github.com/mochajs/mocha) test framework.

Running the tests:

```shell
# All tests
npm run test

# Unit tests only
npm run test:unit

# Integration tests only
npm run test:integration
```

To generate reults appropriate for the **pipeline** `mocha` needs to run with a different set of options (see [mocha.pipeline.opts](tests/js/mocha.pipeline.opts)).

Running the tests using the **pipeline** options:

```shell
# All tests
npm run test:pipeline

# Unit tests only
npm run test:pipeline:unit

# Integration tests only
npm run test:pipeline:integration
```

####  Building

##### OSX
Build the electron app with:
```shell
npm run build
```
The resulting `.app` can be found in `unicorn/Unicorn-darwin-x64/`

##### Windows
TODO


#### Signing

WARNING: In progress and subject to change.
* Current workaround to sign the electron app: if you have the certificate `Developer ID Application: Numenta, Inc. (2589Z673MU)` you can add `--sign='Developer ID Application: Numenta, Inc. (2589Z673MU)'` at the end the `electron-packager` command of the `build` script in `package.json`. This will build and sign the app.
* Useful blog post about signing Electron apps: http://jbavari.github.io/blog/2015/08/14/codesigning-electron-applications

#### Releasing the app in the AppStore
* Currently, the instructions to release an Electron app on the app store can be found here: http://www.saschawise.com/blog/2015/08/12/electron-for-the-mac-app-store.html

#### Lint

Make sure your code is clean from `lint` errors before creating pull requests:

```shell
npm run lint
```

### Debugging

#### Backend

* @TODO Python, NuPIC, Models, debugging etc.

#### Frontend + Browser

* [Electron + Chrome debug shortcuts](https://github.com/sindresorhus/electron-debug)
* [React Chrome browser plugin](http://electron.atom.io/docs/v0.31.0/tutorial/devtools-extension/)
* [Chrome DevTools plugin](http://electron.atom.io/docs/v0.31.0/tutorial/devtools-extension/)

#### Command-line

* [Electron debugging switches](https://github.com/atom/electron/blob/master/docs/tutorial/debugging-main-process.md)
* [Chrome switches supported in Electron](http://electron.atom.io/docs/v0.31.0/api/chrome-command-line-switches/)

#### Node/io.js system-level

* [Electron with node-inspector](https://github.com/atom/electron/blob/master/docs/tutorial/debugging-main-process.md)
* [Node debugger](https://nodejs.org/api/debugger.html)

#### Other Debugging

* [Electron and Windows Debug Symbol Server](http://electron.atom.io/docs/v0.31.0/development/setting-up-symbol-server/)

#### Problems? and Hints

* Make sure to update packages often, especially after pulling an update into
  your branch:
  * `npm run check`
  * `pip list --outdated`
* Sometimes `node_modules/` directory can become corrupted, try cleaning and
  reinstalling: `npm run clean ; npm run check`
* [Awesome Node.js list](https://github.com/sindresorhus/awesome-nodejs)


## Pending @TODOs below...

Highest priority items listed on top. The following need to be JIRA-tized, or
may be too low priority to worry about yet. -@brev

* Gulp/Webpack config settings for loading differing bundle/code for
  Desktop or Browser. Split build sources and targets for certain dirs?
  Sync with recent `nconf` work.
* Setup logging: Winston or Bunyan? => Joe thinking about it.
* Errors are not that helpful so far, need to improve this
  * Seemed like webpack / babel build errors were not killing the 'npm start'
    flow, missing exit code in package.json?
* Add in Flow type checking
* i18n l10n setup (es6 template strings? react intl? es6/7 solution?)
* Document where are imports=>requires handled? Babel/Webpack?
* add Architecture docs and charts
  * Copy in ARch doc Errors section to this doc
    * Errors can do screenshots:
      https://github.com/atom/electron/blob/master/docs/api/browser-window.md#browserwindowcapturepagerect-callback
* JS formatting: [jsfmt](https://github.com/rdio/jsfmt) - NO ES6 yet!
